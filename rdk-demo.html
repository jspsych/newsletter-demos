<!DOCTYPE html>
<html>
  <head>
    <title>Random Dot Kinematogram Demo</title>
    <script src="https://unpkg.com/jspsych@8.0.3"></script>
    <script src="https://unpkg.com/@jspsych/plugin-preload"></script>
    <script src="https://unpkg.com/@jspsych/plugin-html-keyboard-response"></script>
    <script src="https://unpkg.com/@jspsych-contrib/plugin-rdk@2.0.0"></script>
    <link href="https://unpkg.com/jspsych@8.0.3/css/jspsych.css" rel="stylesheet" type="text/css" />
  </head>
  <body></body>
  <script>
    const jsPsych = initJsPsych({
      on_finish: function(){
        jsPsych.data.displayData();
      }
    });

    var timeline = [];

    const introduction = {
        type: jsPsychHtmlKeyboardResponse,
        stimulus: `
            <h3 style='padding: 0 2em;'>
                You're about to get a quick demo of jsPsych's Random Dot Kinematogram plugin, 
                courtesy of Rajanandan, Lau, and Odegaard. While not exhaustive, the demo will 
                walk you through a few key parameters in the plugin. Press any key to continue
                from each screen, including the RDK displays.
            </h3>
        `,
        prompt: "<p>Press any key to continue.</p>"
    }

    const coherence_introduction = {
        type: jsPsychHtmlKeyboardResponse,
        stimulus: `
            <h3 style='padding: 0 2em;'>
                The first parameter we'll look at is "coherence." This determines the proportion of dots
                assigned as signal dots at any given time.
            </h3>
        `,
        prompt: "<p>Press any key to continue.</p>"
    }
    const coherence_instructions = {
        type: jsPsychHtmlKeyboardResponse,
        stimulus: () => `
            <h3 style='padding: 0 2em;'>
                The next screen shows a dot kinematogram with a coherence of ${jsPsych.evaluateTimelineVariable('coherence')}.
            </h3>
        `,
        prompt: "<p>Press any key to continue.</p>"
    }
    const coherence = {
        type: jsPsychRdk,
        choices: "ALL_KEYS",
        correct_choice: "ALL_KEYS",
        trial_duration: -1,
        coherence: jsPsych.timelineVariable('coherence'),
    }

    const rdk_type_introduction = {
        type: jsPsychHtmlKeyboardResponse,
        stimulus: `
            <h3 style='padding: 0 2em;'>
                This last parameter, "RDK_type," most dramatically influences the RDK's behavior.
                It features six different settings between 1 and 6. Each setting determines (1)
                how signal dots are assigned, and (2) how noise dots behave. For these last RDKs,
                we'll keep a direction of 0 degrees, a coherence of 0.5, and an opposite coherence of 0.
            </h3>
        `,
        prompt: "<p>Press any key to continue.</p>"
    }
    const rdk_type_instructions = {
        type: jsPsychHtmlKeyboardResponse,
        stimulus: () => `
            <h3 style='padding: 0 2em;'>
                In the next screen, dots are assigned as "signal" or "noise" ${jsPsych.evaluateTimelineVariable('signal')},
                and noise dots ${jsPsych.evaluateTimelineVariable('noise')}.
            </h3>
        `,
        prompt: "<p>Press any key to continue.</p>"
    }
    const rdk_type = {
        type: jsPsychRdk,
        choices: "ALL_KEYS",
        correct_choice: "ALL_KEYS",
        trial_duration: -1,
        RDK_type: jsPsych.timelineVariable('RDK_type'),
    }

    const direction_introduction = {
        type: jsPsychHtmlKeyboardResponse,
        stimulus: `
            <h3 style='padding: 0 2em;'>
                Next, we'll demo the direction parameter, which controls the direction signal dots move in.
                This parameter is specified in degrees, with 0 degrees pointing to the right of the screen,
                and each degree shifting the direction counterclockwise. The next few RDKs will all keep
                a coherence of 0.5.
            </h3>
        `,
        prompt: "<p>Press any key to continue.</p>"
    }
    const direction_instructions = {
        type: jsPsychHtmlKeyboardResponse,
        stimulus: () => `
            <h3 style='padding: 0 2em;'>
                The next screen features signal dots moving at ${jsPsych.evaluateTimelineVariable('coherent_direction')} degrees,
                or ${jsPsych.evaluateTimelineVariable('direction')}.
            </h3>
        `,
        prompt: "<p>Press any key to continue.</p>"
    }
    const direction = {
        type: jsPsychRdk,
        choices: "ALL_KEYS",
        correct_choice: "ALL_KEYS",
        trial_duration: -1,
        coherent_direction: jsPsych.timelineVariable('coherent_direction'),
    }

    const opposite_introduction = {
        type: jsPsychHtmlKeyboardResponse,
        stimulus: `
            <h3 style='padding: 0 2em;'>
                Next, we'll demo the "opposite_coherence" parameter. This specifies the proportion of
                total dots that move in the opposite direction of the signal dots. Like coherence, this
                parameter is relative to the total number of dots, not the amount of signal or noise dots. 
                For instance, an opposite coherence of 0.1 will affect 30 out of 300 dots in an RDK of 
                coherence 0.5, rather than 15 out of 150 noise dots. The next few RDKs will keep to a 
                direction of 0 degrees (to the right) and a coherence of 0.5.
            </h3>
        `,
        prompt: "<p>Press any key to continue.</p>"
    }
    const opposite_instructions = {
        type: jsPsychHtmlKeyboardResponse,
        stimulus: () => `
            <h3 style='padding: 0 2em;'>
                The next screen will demonstrate an opposite coherence of ${jsPsych.evaluateTimelineVariable('opposite_coherence')}.
            </h3>
        `,
        prompt: "<p>Press any key to continue.</p>"
    }
    const opposite = {
        type: jsPsychRdk,
        choices: "ALL_KEYS",
        correct_choice: "ALL_KEYS",
        trial_duration: -1,
        opposite_coherence: jsPsych.timelineVariable('opposite_coherence'),
    }

    const coherence_screens = {
        timeline: [coherence_instructions, coherence],
        timeline_variables: [
            { coherence: 0 },
            { coherence: 0.1 },
            { coherence: 0.3 },
            { coherence: 0.5 },
        ]
    }
    const coherence_demo = {
        timeline: [coherence_introduction, coherence_screens]
    }
    const rdk_type_screens = {
        timeline: [rdk_type_instructions, rdk_type],
        timeline_variables: [{ 
                RDK_type: 1, 
                signal: 'consistently across all frames',
                noise: 'appear in random locations each frame'
            },{ 
                RDK_type: 2, 
                signal: 'consistently across all frames',
                noise: 'move in random directions each frame'
            },{ 
                RDK_type: 3, 
                signal: 'consistently across all frames',
                noise: 'move in an incoherent but consistent direction across all frames'
            },{ 
                RDK_type: 4, 
                signal: 'randomly each frame',
                noise: 'appear in random locations'
            },{ 
                RDK_type: 5, 
                signal: 'randomly each frame',
                noise: 'move in random directions' 
            },{ 
                RDK_type: 6, 
                signal: 'randomly each frame',
                noise: 'move in an incoherent but consistent direction across all frames'
            },
        ]
    }
    const rdk_type_demo = {
        timeline: [rdk_type_introduction, rdk_type_screens]
    }
    const direction_screens = {
        timeline: [direction_instructions, direction],
        timeline_variables: [
            { coherent_direction: 0, direction: 'to the right' },
            { coherent_direction: 90, direction: 'straight up' },
            { coherent_direction: 180, direction: 'to the left'},
            { coherent_direction: 270, direction: 'straight down' },
        ]
    }
    const direction_demo = {
        timeline: [direction_introduction, direction_screens]
    }
    const opposite_screens = {
        timeline: [opposite_instructions, opposite],
        timeline_variables: [
            { opposite_coherence: 0 },
            { opposite_coherence: 0.1 },
            { opposite_coherence: 0.2},
            { opposite_coherence: 0.3},
        ]
    }
    const opposite_demo = {
        timeline: [opposite_introduction, opposite_screens]
    }

    timeline.push(introduction, coherence_demo, direction_demo, opposite_demo, rdk_type_demo);

    jsPsych.run([timeline]);
  </script>
</html>
